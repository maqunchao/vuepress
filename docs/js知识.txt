consolg.log(0.1 +0.2 == 0.3); 输出结果是false， 浮点数运算的精度问题导致等式左右的结果并不是严格相等
十进制小数转二进制的算法是：
整数部分：除 2 取余，直到商数为 0，结果逆序排列；
小数部分：乘 2 取整，直到小数部分乘积积为 0，结果顺序排列；
以0.125为例演示如下：
0.125 × 2 = 0.25 .......................0
0.25 × 2 = 0.5 .......................0
0.5 × 2 = 1.0 .......................1
即 十进制的0.125，表示成二进制为 0.001

现在来看十进制的0.1 转二进制：
0.1 × 2 = 0.2 .....................0
0.2 × 2 = 0.4 .....................0
0.4 × 2 = 0.8 .....................0
0.8 × 2 = 1.6......................1
0.6 × 2 = 1.2......................1
0.2 × 2 = 0.4......................0
这个算法过程是无限循环的，因此可以得出结论：浮点数的小数部分会有精度丢失问题

Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON

函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部

如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值


加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算

数组的forEach方法可以改变原数组的值, map方法不能改变原数组的值, 并且需要返回值

1. 闭包

闭包简单理解成“定义在一个函数内部的函数”。
闭包最大的特点，就是它可以“记住”诞生的环境
闭包的最大用处有两个，一个是可以读取函数内部的变量，
另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在

1.1 js闭包是函数和声明该函数的词法环境的组合。(如果一个函数用到了外部的变量,那么这个函数加这个变量就叫做闭包)
function init() {
    var name = "Mozilla"; // name 是一个被 init 创建的局部变量
    function displayName() { // displayName() 是内部函数,一个闭包
        alert(name); // 使用了父函数中声明的变量
    }
    displayName();
}
init();

词法作用域中使用的域，是变量在代码中声明的位置所决定的。
嵌套的函数可以访问在其外部声明的变量。
JavaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法环境组合而成。
这个环境包含了这个闭包创建时所能访问的所有局部变量。


JavaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量

function a() {
    var i = 0;
    function b() {
        alert(++i);
    }
    return b;
}
var c = a();
c();
这段代码有两个特点：

函数b嵌套在函数a内部；
函数a返回函数b

这样在执行完var c=a()后，变量c实际上是指向了函数b，b中用到了变量i，再执行c()后就会弹出一个窗口显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b，就是说：

当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个我们通常所谓的“闭包”。


1.类似数组的对象
如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。

与NaN的比较。任何值（包括NaN本身）与NaN比较，返回的都是false

对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是false. 而大于或小于运算符比较的是值


且运算符（&&）运算规则是：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值

除了加法运算符（+）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值,通过Number

一个数与自身的取反值相加，等于-1 减去这个数

十进制：没有前导0的数值。
八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。
十六进制：有前缀0x或0X的数值。
二进制：有前缀0b或0B的数值。

相对路径是相当于当前目录的,不能以/开头
绝对路径是从根目录开始的,一定以/开头(~也是绝对路径, 因为~是/c/Users/xxx 这类路径的缩写)

1.数组的方法
map和forEach方法不会跳过undefined和null, 但是会跳过空位
数组的map和forEach()方法 除了参数是一个函数, 该函数可接受3个参数:当前值, 当前位置, 整个数组.
也可以接受第2个参数,绑定参数函数的this变量.
filter的过滤数组成员,参数同上.

some() 只要一个成员的返回值是true, 整个方法的返回值就是true,否则返回false.
every()方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false

2.数组的 reduce(), reduceRight(), 一次处理数组的每个成员,最终累计为一个值
.1第一个参数都是一个函数。该函数接受以下四个参数。
.2累积变量，默认为数组的第一个成员
.3当前变量，默认为数组的第二个成员
.4当前位置（从0开始）
前两个必须, 后两个可选
如果要对累积变量指定初值，可以把它放在reduce方法和reduceRight方法的第二个参数

//Object的create
var obj = {name:'mark'};
var obj2 = new Object({name:'jack'});

obj.__proto__ == obj2.__proto__
true  
var obj = Object.create({name:'jack'});
Object.create方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。
等于obj.__proto == obj2;  将obj的原型指向了obj2;

obj.__proto__ == obj2.__proto__
false

obj.__proto__.__proto__ == obj2.__proto__
true

Ramda Underscore lodash

提交首屏加载速度
1.代码压缩
2.利用webpack大法的code splitting, 进行路由懒加载, 按需加载
3.CDN引入
4.SSR服务器渲染
5.增加带宽
6.提取第三方库 vendor, 也属于webpack大法的code splitting

